Pre-emptive:

#include <stdio.h> 
#define MAX 10 
typedef struct { 
 int pid, at, bt, rt, wt, tat, completed; 
} Process; 
void sjf_preemptive(Process p[], int n) { 
 int time = 0, completed = 0, shortest = -1, min_bt = 9999;                                          
 while (completed < n) { 
 shortest = -1; 
 min_bt = 9999; 
 for (int i = 0; i < n; i++) { 
 if (p[i].at <= time && p[i].rt > 0 && p[i].rt < min_bt) {  min_bt = p[i].rt; 
 shortest = i; 
 } 
 } 
 if (shortest == -1) { 
 time++; 
 continue; 
 } 
 p[shortest].rt--; 
 time++; 
 if (p[shortest].rt == 0) { 
 p[shortest].completed = 1; 
 completed++; 
 p[shortest].tat = time - p[shortest].at; 
 p[shortest].wt = p[shortest].tat - p[shortest].bt;  }

 } 
} 
int main() { 
 Process p[MAX]; 
 int n; 
 printf("Enter number of processes: "); 
 scanf("%d", &n); 
 for (int i = 0; i < n; i++) {                                                                                           
 p[i].pid = i + 1; 
 printf("Enter arrival time and burst time for process %d: ", p[i].pid);  scanf("%d %d", &p[i].at, &p[i].bt); 
 p[i].rt = p[i].bt; 
 p[i].completed = 0; 
 } 
 sjf_preemptive(p, n); 
 printf("\nPID\tAT\tBT\tWT\tTAT\n"); 
 for (int i = 0; i < n; i++) 
 printf("%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].at, p[i].bt, p[i].wt, p[i].tat); 
 return 0; 
} 


Non Pre-emptive:

#include <stdio.h> 
#include <limits.h> 
struct Process { 
 int at; 
 int bt; 
 int ct; 
 int tat; 
 int wt; 
 int rt; 
 int pid; 
}; 
void calculateSJF(struct Process proc[], int n) { 
 int time = 0; 
 int completed = 0; 
 int min_index; 
 int is_completed[n]; 
 for (int i = 0; i < n; i++) { 
 is_completed[i] = 0;

 } 
 while (completed < n) { 
 min_index = -1; 
 int min_bt = INT_MAX; 
 for (int i = 0; i < n; i++) { 
 if (proc[i].at <= time && !is_completed[i] && proc[i].bt < min_bt) {  min_bt = proc[i].bt; 
 min_index = i; 
 } 
 } 
 if (min_index == -1) { 
 time++; 
 } else { 
 proc[min_index].ct = time + proc[min_index].bt; 
 proc[min_index].tat = proc[min_index].ct - proc[min_index].at;  proc[min_index].wt = proc[min_index].tat - proc[min_index].bt;  proc[min_index].rt = time - proc[min_index].at; 
 time = proc[min_index].ct; 
 is_completed[min_index] = 1; 
 completed++; 
 } 
 } 
}                                                                                                                                                      
int main() { 
 int n; 
 printf("Enter number of processes: "); 
 scanf("%d", &n); 
 struct Process proc[n]; 
 printf("Enter Arrival Time and Burst Time for each process:\n"); 
 for (int i = 0; i < n; i++) { 
 proc[i].pid = i + 1; 
 printf("P%d Arrival Time: ", i + 1); 
 scanf("%d", &proc[i].at); 
 printf("P%d Burst Time: ", i + 1); 
 scanf("%d", &proc[i].bt); 
 } 
 calculateSJF(proc, n); 
 printf("\nProcess\tAT\tBT\tCT\tTAT\tWT\tRT\n"); 
 for (int i = 0; i < n; i++) { 
 printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n", proc[i].pid, proc[i].at, proc[i].bt, proc[i].ct,  proc[i].tat, proc[i].wt, proc[i].rt); 
 }

 float totalWT = 0, totalTAT = 0; 
 for (int i = 0; i < n; i++) { 
 totalWT += proc[i].wt; 
 totalTAT += proc[i].tat; 
 } 
 printf("\nAverage Waiting Time: %.2f", totalWT / n); 
 printf("\nAverage Turnaround Time: %.2f\n", totalTAT / n); 
 return 0; 
} 

